# 977.有序数组的平方
[力扣题目链接](https://leetcode.cn/problems/squares-of-a-sorted-array/)
## 我的代码实现
```python
class Solution(object):
    def sortedSquares(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """

        //不能直接nums_square=[] 
        //否则后面全都不能用index直接赋值，因为任何index都不存在
        //或者
        //直接nums_square=[] 
        //nums_square.append()
        nums_square = [None]*len(nums)

        if nums[0] >= 0:
            for i in range(len(nums)):
                //可以简化为nums[i] *= nums[i]就是用平方值代替原值存入原数组
                //但是此处是需要存入nums_square数组因此不太合适，不过这种简化的写法值得留意
                nums_square[i] = nums[i] * nums[i]
        elif nums[len(nums)-1] <= 0:
            k = 0

            //注意range用法，左闭右开，最后一个参数是步长
            for i in range(len(nums) - 1, -1, -1):
                nums_square[k] = nums[i] * nums[i]
                k += 1
        else:
            for i in range(len(nums)):
                if nums[i] > 0:
                    pos = i

                    //注意break，元素没for完，中途出循环不继续for后面的了
                    //对比continue，跳过目前这个元素，继续for下一个
                    break
            
            //很像重温mergesort的merge那一部分，将两部分有序merge成一整个有序
            slow = i-1
            fast = i
            counter = 0
            while slow >= 0 and fast < len(nums):
                if nums[slow]**2 <= nums[fast]**2:
                    nums_square[counter] = nums[slow]**2
                    counter += 1
                    slow -= 1
                else:
                    nums_square[counter] = nums[fast]**2
                    counter += 1
                    fast += 1
            if slow >= 0:
                for index in range (slow, -1, -1):
                    nums_square[counter] = nums[index]**2
                    counter += 1
            elif fast < len(nums):
                for index in range(fast, len(nums)):
                    nums_square[counter] = nums[index]**2
                    counter += 1
        return nums_square
```
## 优化
我开始想到了正负交界处的平方是小的，但缺少逆向思维（两个逆向思维，一是中间小转为两边大，二是从小到大转为从大到小），两边是大的可以先排后面往前排，或者先从大到小排然后利用`[::-1]`翻转成由小到大

从而浪费在判断是否有正负交界以及寻找正负交界的非必要操作上

因此直接以我的解法的找到正负交界之后的操作为基础，改中间走向两边为两边走向相遇即可解决问题，优化解法，虽然bigo均为O(n)
```python
class Solution(object):
    def sortedSquares(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        slow = 0
        fast = len(nums) - 1
        counter = len(nums) - 1
        nums_square = [None]*len(nums)
        //有些语言也有for的写法
        //for (int slow = 0, fast = nums.size() - 1; slow <= fast;) 这里是小于等于，因为快慢指针相遇时还要进入循环将它们指向的值进行处理
        //标准结构：for (initialization; condition; update) 
        //此处变形：initialization 初始化两个变量slow和fast; condition slow <= fast; update 省略，意味着指针更新的操作会在循环体内部进行
        //Python 的 for 循环通常用于遍历一个可迭代对象，因此没有这种写法，用for写会比较复杂：
        //for slow, fast in zip(range(len(nums)), range(len(nums) - 1, -1, -1)):
        //if slow > fast:
        // break
        while counter >= 0:
            if nums[fast]**2 >= nums[slow]**2:
                nums_square[counter] = nums[fast]**2
                fast -= 1
                counter -= 1
            else:
                nums_square[counter] = nums[slow]**2
                slow += 1
                counter -= 1
            //两种情况都需要counter递减，因此可以提取出来放到while循环里这层
            //counter -= 1
        return nums_square
```