# 203. 移除链表元素
[力扣题目链接](https://leetcode.cn/problems/remove-linked-list-elements/description/)
## 删除节点两种情况：  
1. 删除头节点：head = head.next  
2. 删除非头节点：node.next = node.next.next
3. 增加 dummy head 统一两种情况，同理，dummy head也可以统一增加节点的两种情况  
### 代码实现
```python
#dummy head solution

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:
        dummy = ListNode(0)
        dummy.next = head
        node = dummy
        while node.next != None:
            if node.next.val == val:
                node.next = node.next.next
            else:
                node = node.next 
        return dummy.next 
```
```python
#head 和 非head 分开处理

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:
        while head != None and head.val == val:
            head = head.next
        if head == None: #这里的if判断多余可以直接并进下一个while，空链表head不会进入两个whileloop直接return null
            return head
        node = head 
        while node.next != None: #如上所述，如果if判断去掉这里需要改成while node != None and node.next != None
            if node.next.val == val:
                node.next = node.next.next
            else: 
                node = node.next
        return head
```
```python
#head 和 非head 分开讨论 整体处理
#问题：走到valnode时怎么知道prev来删？答：多记录一个prev变量

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:
        node = head
        prev = head
        while node != None:
            if node.val == val:
                if node == head:
                    head = head.next
                    node = head
                    prev = head
                else:
                    node = node.next
                    prev.next = prev.next.next
            else:
                prev = node
                node = node.next
        return head
```
## 链表的递归属性  
[油管Professor Kevin Wortman的linear recursion教程](https://www.youtube.com/watch?v=_sqAF7llUec&list=PLd9A0clOZAdU_7z5kSlKldniK6yuREHPD&index=28)  
[油管Professor Kevin Wortman的singlelinkedlist-recursion教程](https://www.youtube.com/watch?v=AVjPPv2kCrQ&list=PLd9A0clOZAdU_7z5kSlKldniK6yuREHPD&index=27)  
![链表的递归属性](concept.png)
![linear recursion function pattern](pattern.png)
![leapoffaith](leapoffaith.png)
```python
#递归

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:
        if head == None:
            return None
        
        #递归的信仰：子问题已经被完美解决了
        head.next = self.removeElements(head.next, val)

        if head.val == val:
            return head.next
        else:
            return head
```
### 代码随想录的递归思路  
基础情况：对于空链表，不需要移除元素。  
递归情况：首先检查头节点的值是否为 val，如果是则移除头节点，答案即为在头节点的后续节点上递归的结果；如果头节点的值不为 val，则答案为头节点与在头节点的后续节点上递归得到的新链表拼接的结果。（这个解释掺杂了递归调用的过程，但在思考递归解法的时候非必须理解，而是可以简化为上文递归的思路假设子问题已解决，专注当前层，具体子问题怎么解决的，怎么联系到当前层，是递归调用的过程不用捋出来也不影响写出递归解法）
```python
#其实就是把子问题的解决和当前层混杂，上面的递归解法子问题和当前层前后顺序分开更加清晰，混杂在一起就要尤其注意不要丢掉return，return是将当前层变化传递到其他层使用的唯一途径，没有return，当前层的任何变化仅局限于当前层，没有传递没有意义
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:
        if head == None:
            return None
        if head.val == val:
            head = self.removeElements(head.next, val)
            return head #这里改成return self.removeElements(head.next, val) 更好，回避中间变量head改变结构，避免使用局部变量导致遗漏return返回值链断掉，真正控制链表结构的是next指针而不是局部变量head
        if head.val != val:
            head.next = self.removeElements(head.next, val)
            return head
```

